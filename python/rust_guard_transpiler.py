#!/usr/bin/env python3
"""
Rust Guard Transpiler

Transpiles Lean predicates to optimized Rust code with proper error handling.
This implements the Rust guard generation part of DSS-5.

Usage:
    python rust_guard_transpiler.py --input predicates.lean --output rust_guards.rs
"""

import sys
import os
import re
import json
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
import logging


class RustGuardTranspiler:
    """Transpiles Lean predicates to optimized Rust code."""

    def __init__(self):
        self.logger = logging.getLogger("RustGuardTranspiler")
        self.transpilation_stats = {
            "predicates_processed": 0,
            "functions_generated": 0,
            "errors": 0,
            "warnings": 0,
        }

        # Rust code templates
        self.rust_templates = {
            "module_header": """// Auto-generated Rust guards from Lean predicates
// Generated by: rust_guard_transpiler.py

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use regex::Regex;
use lazy_static::lazy_static;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Row {
    pub phi: Vec<String>,
    pub age: Option<u32>,
    pub gdpr_special: Vec<String>,
    pub custom_fields: Vec<(String, String)>,
}

impl Row {
    pub fn new() -> Self {
        Self {
            phi: Vec::new(),
            age: None,
            gdpr_special: Vec::new(),
            custom_fields: Vec::new(),
        }
    }

    pub fn with_phi(mut self, phi: Vec<String>) -> Self {
        self.phi = phi;
        self
    }

    pub fn with_age(mut self, age: u32) -> Self {
        self.age = Some(age);
        self
    }

    pub fn with_gdpr_special(mut self, gdpr: Vec<String>) -> Self {
        self.gdpr_special = gdpr;
        self
    }

    pub fn with_custom_fields(mut self, fields: Vec<(String, String)>) -> Self {
        self.custom_fields = fields;
        self
    }
}

impl Default for Row {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions for pattern matching
lazy_static! {
    static ref PHI_PATTERNS: Vec<Regex> = vec![
        Regex::new(r"SSN").unwrap(),
        Regex::new(r"social security").unwrap(),
        Regex::new(r"medical record").unwrap(),
        Regex::new(r"health plan").unwrap(),
        Regex::new(r"patient").unwrap(),
        Regex::new(r"diagnosis").unwrap(),
        Regex::new(r"treatment").unwrap(),
        Regex::new(r"prescription").unwrap(),
    ];
}

fn contains_phi(text: &str) -> bool {
    PHI_PATTERNS.iter().any(|pattern| pattern.is_match(text))
}

""",
            "function_template": """#[inline]
pub fn {function_name}(row: &Row) -> bool {{
    {function_body}
}}""",
            "test_template": """#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_{function_name}() {{
        let row = Row::new()
            .with_phi(vec!["SSN: 123-45-6789".to_string()])
            .with_age(25);
        
        let result = {function_name}(&row);
        assert!(result, "{function_name} should detect violation");
    }}

    #[test]
    fn test_{function_name}_clean() {{
        let row = Row::new()
            .with_age(25);
        
        let result = {function_name}(&row);
        assert!(!result, "{function_name} should not detect violation in clean data");
    }}
}}""",
            "cargo_toml": """[package]
name = "ds-guard"
version = "0.1.0"
edition = "2021"
description = "Dataset safety guards generated from Lean predicates"
license = "MIT"
authors = ["Dataset Safety Specs"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
regex = "1.0"
lazy_static = "1.0"

[dev-dependencies]
criterion = "0.5"

[[bench]]
name = "guard_benchmarks"
harness = false

[lib]
name = "ds_guard"
path = "src/lib.rs"
""",
            "benchmark_template": """use criterion::{{black_box, criterion_group, criterion_main, Criterion}};
use ds_guard::{{Row, {function_names}}};

fn benchmark_guards(c: &mut Criterion) {{
    let test_row = Row::new()
        .with_phi(vec!["SSN: 123-45-6789".to_string()])
        .with_age(25)
        .with_gdpr_special(vec!["diabetes".to_string()]);

    c.bench_function("guard_checks", |b| {{
        b.iter(|| {{
            {benchmark_calls}
        }})
    }});
}}

criterion_group!(benches, benchmark_guards);
criterion_main!(benches);
""",
        }

    def transpile_predicates(self, predicates: List[Dict[str, Any]]) -> str:
        """Transpile Lean predicates to Rust code."""
        self.logger.info(f"Transpiling {len(predicates)} predicates to Rust...")

        generated_functions = []
        generated_tests = []
        function_names = []

        for predicate in predicates:
            try:
                # Transpile individual predicate
                rust_function = self._transpile_predicate(predicate)
                rust_test = self._generate_test(predicate)

                generated_functions.append(rust_function)
                generated_tests.append(rust_test)
                function_names.append(predicate["name"].lower())

                self.transpilation_stats["functions_generated"] += 1

            except Exception as e:
                error_msg = f"Failed to transpile predicate {predicate.get('name', 'unknown')}: {e}"
                self.logger.error(error_msg)
                self.transpilation_stats["errors"] += 1

        # Combine all generated code
        combined_functions = "\n\n".join(generated_functions)
        combined_tests = "\n\n".join(generated_tests)

        # Generate complete module
        rust_module = (
            self.rust_templates["module_header"]
            + "\n"
            + combined_functions
            + "\n\n"
            + combined_tests
        )

        self.transpilation_stats["predicates_processed"] = len(predicates)

        return rust_module

    def _transpile_predicate(self, predicate: Dict[str, Any]) -> str:
        """Transpile a single predicate to Rust function."""
        predicate_name = predicate["name"]
        lean_code = predicate["lean_code"]

        # Convert Lean code to Rust
        rust_body = self._convert_lean_to_rust(lean_code)

        # Generate function
        function_name = f"{predicate_name.lower()}_guard"
        rust_function = self.rust_templates["function_template"].format(
            function_name=function_name, function_body=rust_body
        )

        return rust_function

    def _convert_lean_to_rust(self, lean_code: str) -> str:
        """Convert Lean predicate code to Rust."""
        # Simple conversion rules - in practice would be more sophisticated
        conversions = {
            "has_phi row": "row.phi.iter().any(|field| contains_phi(field))",
            "is_minor row": "row.age.map_or(false, |age| age < 13)",
            "has_gdpr_special row": "!row.gdpr_special.is_empty()",
            "row.phi.any": "row.phi.iter().any",
            "row.age": "row.age",
            "row.gdpr_special": "row.gdpr_special",
            "row.custom_fields": "row.custom_fields",
        }

        rust_code = lean_code
        for lean_pattern, rust_pattern in conversions.items():
            rust_code = rust_code.replace(lean_pattern, rust_pattern)

        return rust_code

    def _generate_test(self, predicate: Dict[str, Any]) -> str:
        """Generate test for a predicate."""
        function_name = f"{predicate['name'].lower()}_guard"

        return self.rust_templates["test_template"].format(function_name=function_name)

    def generate_cargo_toml(self) -> str:
        """Generate Cargo.toml for the Rust crate."""
        return self.rust_templates["cargo_toml"]

    def generate_benchmarks(self, function_names: List[str]) -> str:
        """Generate benchmark code."""
        benchmark_calls = "\n            ".join(
            [f"{name}(black_box(&test_row));" for name in function_names]
        )

        return self.rust_templates["benchmark_template"].format(
            function_names=", ".join(function_names), benchmark_calls=benchmark_calls
        )

    def generate_complete_crate(
        self, predicates: List[Dict[str, Any]], output_dir: str
    ) -> bool:
        """Generate complete Rust crate with all files."""
        try:
            # Create output directory
            Path(output_dir).mkdir(parents=True, exist_ok=True)
            Path(f"{output_dir}/src").mkdir(exist_ok=True)
            Path(f"{output_dir}/benches").mkdir(exist_ok=True)

            # Generate main library code
            rust_module = self.transpile_predicates(predicates)
            with open(f"{output_dir}/src/lib.rs", "w") as f:
                f.write(rust_module)

            # Generate Cargo.toml
            cargo_toml = self.generate_cargo_toml()
            with open(f"{output_dir}/Cargo.toml", "w") as f:
                f.write(cargo_toml)

            # Generate benchmarks
            function_names = [pred["name"].lower() + "_guard" for pred in predicates]
            benchmarks = self.generate_benchmarks(function_names)
            with open(f"{output_dir}/benches/guard_benchmarks.rs", "w") as f:
                f.write(benchmarks)

            # Generate README
            readme = self._generate_readme(predicates)
            with open(f"{output_dir}/README.md", "w") as f:
                f.write(readme)

            self.logger.info(f"âœ“ Rust crate generated in {output_dir}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to generate Rust crate: {e}")
            return False

    def _generate_readme(self, predicates: List[Dict[str, Any]]) -> str:
        """Generate README for the Rust crate."""
        function_list = "\n".join(
            [
                f"- `{pred['name'].lower()}_guard`: {pred.get('description', 'Generated guard')}"
                for pred in predicates
            ]
        )

        return f"""# Dataset Safety Guards - Rust

Auto-generated Rust guards from Lean predicates for dataset safety verification.

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
ds-guard = {{ path = "path/to/ds-guard" }}
```

## Usage

```rust
use ds_guard::{{Row, {", ".join([f"{pred['name'].lower()}_guard" for pred in predicates])}}};

let row = Row::new()
    .with_phi(vec!["SSN: 123-45-6789".to_string()])
    .with_age(25);

if phi_guard(&row) {{
    println!("PHI detected!");
}}
```

## Generated Guards

{function_list}

## Building

```bash
cargo build
cargo test
cargo bench
```

## Performance

The generated guards are optimized for performance with:
- Inline functions for zero-cost abstractions
- Lazy static regex compilation
- Efficient pattern matching

## License

MIT License - Generated from Lean predicates."""

    def get_transpilation_stats(self) -> Dict[str, Any]:
        """Get transpilation statistics."""
        return self.transpilation_stats.copy()


def transpile_lean_predicates(
    predicates: List[Dict[str, Any]], output_dir: str
) -> bool:
    """Convenience function to transpile Lean predicates to Rust."""
    transpiler = RustGuardTranspiler()
    return transpiler.generate_complete_crate(predicates, output_dir)


def main():
    """Main function for command-line usage."""
    import argparse

    parser = argparse.ArgumentParser(description="Rust Guard Transpiler")
    parser.add_argument("--input", type=str, help="Input Lean predicates file")
    parser.add_argument("--output", type=str, help="Output Rust crate directory")
    parser.add_argument("--predicates", type=str, help="JSON file with predicates")

    args = parser.parse_args()

    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Load predicates
    predicates = []

    if args.predicates:
        with open(args.predicates, "r") as f:
            predicates = json.load(f)
    else:
        # Default predicates
        predicates = [
            {
                "name": "PHI",
                "lean_code": "has_phi row",
                "description": "Detects Protected Health Information",
            },
            {
                "name": "COPPA",
                "lean_code": "is_minor row",
                "description": "Detects COPPA violations (age < 13)",
            },
            {
                "name": "GDPR",
                "lean_code": "has_gdpr_special row",
                "description": "Detects GDPR special categories",
            },
        ]

    # Transpile to Rust
    output_dir = args.output or "extracted/rust"
    success = transpile_lean_predicates(predicates, output_dir)

    if success:
        print(f"âœ“ Rust guards generated in {output_dir}")
        print("To build and test:")
        print(f"  cd {output_dir}")
        print("  cargo build")
        print("  cargo test")
        print("  cargo bench")
        sys.exit(0)
    else:
        print("âœ— Failed to generate Rust guards")
        sys.exit(1)


if __name__ == "__main__":
    main()
