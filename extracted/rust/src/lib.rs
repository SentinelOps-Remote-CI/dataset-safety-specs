// Auto-generated Rust guards from Lean predicates
// Generated by: rust_guard_transpiler.py

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use regex::Regex;
use lazy_static::lazy_static;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Row {
    pub phi: Vec<String>,
    pub age: Option<u32>,
    pub gdpr_special: Vec<String>,
    pub custom_fields: Vec<(String, String)>,
}

impl Row {
    pub fn new() -> Self {
        Self {
            phi: Vec::new(),
            age: None,
            gdpr_special: Vec::new(),
            custom_fields: Vec::new(),
        }
    }

    pub fn with_phi(mut self, phi: Vec<String>) -> Self {
        self.phi = phi;
        self
    }

    pub fn with_age(mut self, age: u32) -> Self {
        self.age = Some(age);
        self
    }

    pub fn with_gdpr_special(mut self, gdpr: Vec<String>) -> Self {
        self.gdpr_special = gdpr;
        self
    }

    pub fn with_custom_fields(mut self, fields: Vec<(String, String)>) -> Self {
        self.custom_fields = fields;
        self
    }
}

impl Default for Row {
    fn default() -> Self {
        Self::new()
    }
}

// Helper functions for pattern matching
lazy_static! {
    static ref PHI_PATTERNS: Vec<Regex> = vec![
        Regex::new(r"SSN").unwrap(),
        Regex::new(r"social security").unwrap(),
        Regex::new(r"medical record").unwrap(),
        Regex::new(r"health plan").unwrap(),
        Regex::new(r"patient").unwrap(),
        Regex::new(r"diagnosis").unwrap(),
        Regex::new(r"treatment").unwrap(),
        Regex::new(r"prescription").unwrap(),
    ];
}

fn contains_phi(text: &str) -> bool {
    PHI_PATTERNS.iter().any(|pattern| pattern.is_match(text))
}


#[inline]
pub fn phi_guard(row: &Row) -> bool {
    row.phi.iter().any(|field| contains_phi(field))
}

#[inline]
pub fn coppa_guard(row: &Row) -> bool {
    row.age.map_or(false, |age| age < 13)
}

#[inline]
pub fn gdpr_guard(row: &Row) -> bool {
    !row.gdpr_special.is_empty()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_phi_guard() {
        let row = Row::new()
            .with_phi(vec!["SSN: 123-45-6789".to_string()])
            .with_age(25);
        
        let result = phi_guard(&row);
        assert!(result, "phi_guard should detect violation");
    }

    #[test]
    fn test_phi_guard_clean() {
        let row = Row::new()
            .with_age(25);
        
        let result = phi_guard(&row);
        assert!(!result, "phi_guard should not detect violation in clean data");
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_coppa_guard() {
        let row = Row::new()
            .with_phi(vec!["SSN: 123-45-6789".to_string()])
            .with_age(25);
        
        let result = coppa_guard(&row);
        assert!(result, "coppa_guard should detect violation");
    }

    #[test]
    fn test_coppa_guard_clean() {
        let row = Row::new()
            .with_age(25);
        
        let result = coppa_guard(&row);
        assert!(!result, "coppa_guard should not detect violation in clean data");
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gdpr_guard() {
        let row = Row::new()
            .with_phi(vec!["SSN: 123-45-6789".to_string()])
            .with_age(25);
        
        let result = gdpr_guard(&row);
        assert!(result, "gdpr_guard should detect violation");
    }

    #[test]
    fn test_gdpr_guard_clean() {
        let row = Row::new()
            .with_age(25);
        
        let result = gdpr_guard(&row);
        assert!(!result, "gdpr_guard should not detect violation in clean data");
    }
}